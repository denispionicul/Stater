"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[521],{87303:e=>{e.exports=JSON.parse('{"functions":[{"name":"new","desc":"Returns a new Stater Object.","params":[{"name":"States","desc":"The Table that will have all the States","lua_type":"{[string]: State}"},{"name":"Tick","desc":"Optional tick to be set.","lua_type":"number?"},{"name":"Return","desc":"Determines what to return in the first parameter of each state.","lua_type":"any?"}],"returns":[{"desc":"","lua_type":"Stater\\r\\n"}],"function_type":"static","errors":[{"lua_type":"\\"No States\\"","desc":"Happens when no States are provided"}],"source":{"line":76,"path":"src/init.lua"}},{"name":"RemoveState","desc":"Removes a state inside the states table.","params":[{"name":"Name","desc":"The name of the removing state.","lua_type":"string"}],"returns":[],"function_type":"method","source":{"line":108,"path":"src/init.lua"}},{"name":"AddState","desc":"Adds a state inside the states table. If there is a Start after the State name inside the States, that will play.\\nIf there is a End after the State name inside the States, that will play after the state changes.","params":[{"name":"Name","desc":"The name that the state will go by.","lua_type":"string"},{"name":"State","desc":"The State function itself.","lua_type":"State"}],"returns":[],"function_type":"method","errors":[{"lua_type":"\\"Existing State\\"","desc":"Happens when the name of the state is already inside the table."}],"source":{"line":133,"path":"src/init.lua"}},{"name":"GetCurrentState","desc":"Returns the current state the Stater is on indicated by a string. If none then nil.\\nThis is currently the same as self.State.","params":[],"returns":[{"desc":"","lua_type":"string | nil\\r\\n"}],"function_type":"method","source":{"line":148,"path":"src/init.lua"}},{"name":"IsWorking","desc":"Returns a boolean indicating if the State currently is on.","params":[],"returns":[{"desc":"","lua_type":"boolean\\r\\n"}],"function_type":"method","source":{"line":155,"path":"src/init.lua"}},{"name":"SetState","desc":"Returns a boolean indicating if the State currently is on.","params":[{"name":"State","desc":"The function name inside States represented by a string","lua_type":"string"}],"returns":[],"function_type":"method","errors":[{"lua_type":"\\"No State\\"","desc":"Happens when no State is provided."},{"lua_type":"\\"Invalid State\\"","desc":"Happens when the state provided doesn\'t exist."}],"source":{"line":166,"path":"src/init.lua"}},{"name":"Start","desc":"Begins the Stater","params":[{"name":"State","desc":"The function name inside States represented by a string, this state will be set at the start.","lua_type":"string"}],"returns":[],"function_type":"method","errors":[{"lua_type":"\\"No State\\"","desc":"Happens when no State is provided."},{"lua_type":"\\"Already Started\\"","desc":"Happens when the Stater has already started."}],"source":{"line":196,"path":"src/init.lua"}},{"name":"Stop","desc":"Stops the stater and its state.","params":[],"returns":[],"function_type":"method","errors":[{"lua_type":"\\"Already Stopped\\"","desc":"Happens when the Stater has already been stopped."}],"source":{"line":238,"path":"src/init.lua"}},{"name":"Destroy","desc":"Gets rid of the Stater Object.","params":[],"returns":[],"function_type":"method","source":{"line":258,"path":"src/init.lua"}}],"properties":[],"types":[{"name":"State","desc":"","lua_type":"(Stater) -> boolean?","source":{"line":32,"path":"src/init.lua"}},{"name":"Stater","desc":"","fields":[{"name":"States","lua_type":"{[string]: State}","desc":"The Provided States Table, if theres a \\"Init\\" state then that function will execute each time the Stater Starts."},{"name":"Info","lua_type":"{any?}","desc":"A table that you can add anything in, this is more recommended than directly inserting variables inside the object."},{"name":"Tick","lua_type":"number?","desc":"The time it takes for the current state to be called again after a function is done. Default is 0"},{"name":"Return","lua_type":"any","desc":"This is the thing that returns as the first parameter of every single state. Default is the Stater object itself."},{"name":"State","lua_type":"State","desc":"The current state that the Stater is on."},{"name":"StateConfirmation","lua_type":"boolean","desc":"If this is enabled, the state MUST return a boolean indicating if the function ran properly."},{"name":"Changed","lua_type":"Signal | RBXScriptSignal","desc":"A signal that fires whenever the State changes. Returns Current State and Previous State"},{"name":"StatusChanged","lua_type":"Signal | RBXScriptSignal","desc":"Fired whenever the Stater starts or closes. Returns the current status as a boolean."},{"name":"StateRemoved","lua_type":"Signal | RBXScriptSignal","desc":"A signal that fires whenever a state is added via the Stater:AddState() method. Returns the State Name."},{"name":"StateAdded","lua_type":"Signal | RBXScriptSignal","desc":"A signal that fires whenever a state is removed via the Stater:RemoveState() method. Returns the State Name."}],"source":{"line":47,"path":"src/init.lua"}}],"name":"Stater","desc":"Stater is a finite state machine module with the purpose of easing the creation of ai and npcs in games,\\nStater was built with the intent of being used in module scripts.","source":{"line":16,"path":"src/init.lua"}}')}}]);